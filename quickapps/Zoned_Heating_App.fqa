{"name":"Zoned Heating App","type":"com.fibaro.binarySwitch","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_1236"},"sections":{"items":[{"components":[{"name":"heatingActiveLabel","style":{"weight":"1.2"},"text":"Is heating active on boiler?","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"infoLabel","style":{"weight":"1.2"},"text":"N/A","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"refreshBtnLabel","style":{"weight":"1.2"},"text":"REFRESH","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_1236"}}},"uiCallbacks":[{"callback":"refresh","eventType":"onReleased","name":"refreshBtnLabel"}],"quickAppVariables":[{"name":"BBQGATEWAYTOKEN","type":"password","value":"********"},{"name":"BBQ_API_URL","type":"string","value":"http://192.168.1.16/api"},{"name":"INTERVAL","type":"string","value":"300"}],"typeTemplateInitialized":true},"initialInterfaces":[],"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- Binary switch type should handle actions turnOn, turnOff\n-- To update binary switch state, update property \"value\" with boolean\n\n\nfunction QuickApp:runConfig()\n\n    self.TOKEN = self:getVariable(\"BBQGATEWAYTOKEN\")\n    self.headers = {\n        [\"Content-Type\"] = \"application/json\",\n        [\"Accept\"] = \"application/json\",\n        [\"Authorization\"] = string.format(\"Bearer %s\", self.TOKEN)\n    }\n    self.interval = tonumber(self:getVariable(\"INTERVAL\")) -- in secs\n    self.update_boiler_label_delay = 15 -- in secs\n    self.window_closed_delay = 900 -- in secs\n    self.api_url = self:getVariable(\"BBQ_API_URL\")\n    self.max_temp = 25\n    self.temperature_increase = nil\n    self.hysteresis = 0.3\n    self:debug(\"config initialized\")\nend\n\nfunction QuickApp:endpoint_url(endpoint)\n    if not self.api_url then\n        error(\"self.api_url is missing\")\n    end\n    if not endpoint then\n        error(\"endpoint is missing\")\n    end\n    return string.format(\"%s/%s\", self.api_url, endpoint)\nend\n\n\nfunction QuickApp:refresh(param)\n    self:main()\nend\n\nfunction QuickApp:main(param)\n    sf = string.format\n    local fcol = \"#f3d635\"\n    self:runConfig()\n    self:getTemperatureIncrease()\n\n    self:getControllerTemp(\n        function (response)\n            local controller_currtemp = response.hc1.currtemp\n            local controller_seltemp = response.hc1.seltemp\n            --local msg = ''\n\n            if not controller_currtemp then\n                error(\"controller_currtemp is empty\")\n            end\n            if not controller_seltemp then\n                error(\"controller_seltemp is empty\")\n            end\n            if not self.temperature_increase then\n                error(\"self.temperature_increase is empty\")\n            end\n\n            local override_temp = controller_currtemp + self.temperature_increase\n            local override_temp_rounded = customRound(override_temp)\n            \n            ------------------------ helper function ------------------------\n            local function _set_temp(from_temp, target_temp)\n                self:setControllerTemp(target_temp, function() \n                    self:debug(string.format(\"Controller temperature set from %s to %s\", from_temp, target_temp)) end)\n            end\n\n            local function get_report(msg, use_html)\n                local msg = msg\n                if msg == nil then\n                    error(\"Argument 'msg' is missing.\")\n                end\n                if use_html == nil then\n                    error(\"Argument 'use_html' is missing.\")\n                end\n                \n                local function _span(fcol, str) \n                    if use_html == true then\n                        return span(fcol, str)\n                    else\n                        return str\n                    end\n                end\n                \n                ------------------------ Temperature override logic ------------------------\n                if controller_seltemp == override_temp_rounded then \n                    self:debug(\"Values of 'controller_seltemp' and 'override_temp_rounded' are equal. Nothing to set.\")\n                    msg = msg .. \"ðŸš¨ controller_seltemp == override_temp_rounded ðŸš¨\\n\"\n                elseif temperature_increase == 0 then\n                    self:debug(\"temperature_increase is 0. Nothing to set.\")\n                    msg = msg .. \"ðŸš¨ temperature_increase == 0 ðŸš¨\\n\"\n                elseif override_temp - controller_currtemp <= self.hysteresis then\n                    self:debug(sf(\"temperature diff is less than hysteresis (%s). Nothing to set.\", self.hysteresis))\n                    msg = msg .. sf(\"ðŸš¨  override_temp - controller_currtemp (%s) <= hysteresis (%s) ðŸš¨\\n\",\n                                    _span(fcol, override_temp - controller_currtemp), _span(fcol, self.hysteresis))\n                    -- just set setpoint to current temp and stop heating\n                    _set_temp(controller_currtemp, math.floor(controller_currtemp))\n                elseif override_temp >= self.max_temp and override_temp > controller_currtemp then\n                    override_temp = self.max_temp\n                    self:debug(\"Override temperature is set to maximum: \", self.max_temp)\n                    _set_temp(controller_currtemp, override_temp_rounded)\n                elseif controller_currtemp < override_temp - self.hysteresis then\n                    _set_temp(controller_currtemp, override_temp_rounded)\n                elseif controller_currtemp >= override_temp then\n                    _set_temp(controller_currtemp, controller_currtemp)\n                end\n\n                ------------------------ logs ------------------------\n            \n                msg = msg ..\n                    sf(\"âžž controller_currtemp: %s,\\n\", _span(fcol, controller_currtemp)) .. \n                    sf(\"âžž controller_seltemp: %s,\\n\", _span(fcol, controller_seltemp)) ..\n                    sf(\"âžž temperature_increase: %s,\\n\", _span(fcol, self.temperature_increase)) ..\n                    sf(\"âžž device: %s (ID: %s),\\n\", \n                        _span(fcol, fibaro.getName(self.temperature_increase_deviceID)),\n                        _span(fcol, self.temperature_increase_deviceID)) ..\n                    sf(\"âžž device temp: %s,\\n\", \n                        _span(fcol, fibaro.getValue(self.temperature_increase_deviceID, \"value\"))) ..\n                    sf(\"âžž device setpoint: %s\\n\", _span(fcol, self.temperature_increase_device_setpoint)) ..\n                    sf(\"âžž override_temp: %s,\\n\", _span(fcol, override_temp)) ..\n                    sf(\"âžž override_temp_rounded: %s,\\n\", _span(fcol, override_temp_rounded)) ..\n                    sf(\"âžž Last update: %s\", _span(fcol, os.date(\"%Y-%m-%d %H:%M:%S\", os.time() )))\n                \n                return msg\n            end\n\n            local msg = get_report(\"\", true)     \n            self:debug(msg)\n\n            ------------------------ update labels ------------------------\n            -- delay function because of boiler delay\n            fibaro.setTimeout(self.update_boiler_label_delay * 1000, function()\n                self:heatingActive(function() \n                    if heating_active == nil then\n                        error(\"heating_active is nil\")\n                    elseif heating_active == true then\n                        self:updateView(\"heatingActiveLabel\", \"text\", \n                                        span(\"#9ACD32\", sf(\"âœ”ï¸Ž Heating Active: %s\", heating_active)))\n                        self:turnOn()\n                    else\n                        self:updateView(\"heatingActiveLabel\", \"text\", \n                                        span(\"#DC143C\", sf(\"âœ˜ï¸Ž Heating Active: %s\", heating_active)))\n                        self:turnOff()\n                    end\n\n                    ------------------------ send notifications ------------------------\n                    if controller_seltemp ~= override_temp_rounded then\n                        msg_no_html = get_report(sf(\"Heating report:\\n\\nHeating Active: %s\\n\", heating_active), false)\n                        fibaro.alert('email', {[1] = 2, }, msg_no_html, false)\n                    end\n\n                end)\n             end)\n\n            self:updateView(\"infoLabel\", \"text\", \"Info:\\n\" .. msg)\n        end\n    )    \nend\n\nfunction QuickApp:turnOn()\n    self:debug(\"Boiler is ON\")\n        self:updateProperty(\"value\", true)    \nend\n\nfunction QuickApp:turnOff()\n    self:debug(\"Boiler is OFF\")\n    self:updateProperty(\"value\", false)    \nend\n\nfunction QuickApp:GETrequest(endpoint, cont)\n    api_request(self:endpoint_url(endpoint), \"GET\", self.headers, cont)\nend\n\nfunction QuickApp:getControllerTemp(cont)\n    self:GETrequest(\"thermostat\", cont)\nend\n\nfunction QuickApp:POSTrequest(endpoint, data, cont)\n    if not data then\n        error(\"data parameter is missing.\")\n    end\n    api_request(self:endpoint_url(endpoint), \"POST\", self.headers, cont, data)\nend\n\nfunction QuickApp:setControllerTemp(override_temp, cont)\n    if not override_temp then\n        error(\"override_temp is missing.\")\n    end\n    if not cont then\n        error(\"cont is missing.\")\n    end\n    \n    data = {value = override_temp}\n    self:POSTrequest(\n        \"thermostat/seltemp\",\n        data, \n        function(response)\n            cont(override_temp)\n        end\n    )\nend\n\nfunction QuickApp:heatingActive(cont)\n    self:GETrequest(\"boiler\", function(data) heating_active = data.heatingactive == \"on\"; cont() end)\nend\n\nfunction QuickApp:thermostaSeltemp(cont)\n    self:GETrequest(\"thermostat/seltemp\", function(data) seltemp = data.value; cont() end)\nend\n\nfunction QuickApp:preconfig(heating_active, seltemp)\n   print(\"heating_active: \", heating_active)\n   seltemp(\"seltemp: \", seltemp) \nend\n\nfunction QuickApp:loop()\n    self:main(param)\n    fibaro.setTimeout(self.interval * 1000, function() \n        self:loop()\n    end)\nend \n\nfunction QuickApp:onInit(param)\n    self:debug(\"Init\")\n    self:runConfig()\n    self:main(param)\n     ------------------------ loop starts here ------------------------\n    self:loop()\nend\n\n\n"},{"name":"http_client","isMain":false,"isOpen":true,"content":"-- Binary switch type should handle actions turnOn, turnOff\n-- To update binary switch state, update property \"value\" with boolean\n\nfunction api_request(address, method, headers, cont, request_body, checkCertificate)\n    local http = net.HTTPClient({timeout = 3 * 1000})\n\n    http:request(address, {\n        options={\n            data = json.encode(request_body or {}),\n            headers = headers,\n            checkCertificate = checkCertificate or false,\n            method = method\n        },\n        success = function(response)\n            if (response.status == 200 or response.status == 201) then\n                cont(json.decode(response.data))\n            else\n                error(\"Error: \" .. response.status);\n            end\n        end,\n        error = function(e)\n            error(e)\n        end\n    })\nend\n\n"},{"name":"utils","isMain":false,"isOpen":true,"content":"function mergeTables(table1, table2)\n  for k, v in pairs (table1) do table.insert(table2, v) end\n  return table2\nend\n\n-- http://lua-users.org/wiki/CopyTable\nfunction deepcopy(orig)\n    local orig_type = type(orig)\n    local copy\n    if orig_type == 'table' then\n        copy = {}\n        for orig_key, orig_value in next, orig, nil do\n            copy[deepcopy(orig_key)] = deepcopy(orig_value)\n        end\n        --setmetatable(copy, deepcopy(getmetatable(orig)))\n    else -- number, string, boolean, etc\n        copy = orig\n    end\n    return copy\nend\n\n\nfunction round(x)\n  return x>=0 and math.floor(x+0.5) or math.ceil(x-0.5)\nend\n\n-- use custom rounding to fit logic of CW100 thermostat\nfunction customRound(number)\n    local decimalPart = number % 1\n    if decimalPart == 0 then\n        return number\n    elseif decimalPart <= 0.5 then\n        return math.floor(number) + 0.5\n    else\n        return math.floor(number + 0.5)\n    end\nend\n\nfunction span(col, str)\n    if not col then\n        error(\"'col' argument is missing\")\n    end\n    if not str then\n        error(\"'str' argument is missing\")\n    end\n    return \"<b><font color=\"..col..\">\"..str..\"</font></b>\" \nend\n\nfunction isNumber(variable)\n    return type(variable) == \"number\"\nend\n"},{"name":"getFilteredDevices","isMain":false,"isOpen":true,"content":"local deviceFilter = \n    {\n        filters = {\n            {\n                filter = \"enabled\",\n                value = { true }\n            },\n            {\n                filter = \"visible\",\n                value = { true }\n            },\n            {\n                filter = \"hasProperty\",\n                value = { \"climateZoneId\"}\n            }\n        }, \n        attributes = {\n            -- define the list of Fibaro device attributes we are interested in\n            main = {\n                \"id\", \"type\", \"baseType\", \"name\", \"properties\", \"parentId\"\n            }\n        }\n    }\n\nfunction getFilteredDevices()\n\n    filters1 = deepcopy(deviceFilter)\n    table.insert(filters1.filters, { filter = \"type\", value = {\"com.fibaro.hvacSystem\"} })\n\n    filters2 = deepcopy(deviceFilter)\n    table.insert(filters2.filters, { filter = \"type\", value = {\"com.fibaro.FGT001\"} })\n        \n    filteredDevices = api.post(\"/devices/filter\", filters1)\n    filteredDevices2 = api.post(\"/devices/filter\", filters2)\n\n    for _, v in pairs(filteredDevices2) do table.insert(filteredDevices, v) end -- merge tables\n\n    return filteredDevices\nend\n"},{"name":"QA_methods","isMain":false,"isOpen":true,"content":"function QuickApp:getTemperatureIncrease(param)\n    filteredDevices = getFilteredDevices()\n    \n    self.temperature_increase = nil\n    self.temperature_increase_deviceID = nil\n\n    for i=1,#filteredDevices do\n        local dev = filteredDevices[i]\n\n        ------------------------ some edge condition checks ------------------------\n\n        -- logic for Heatit Z-temp2 thermostats: if Idle then skip\n        if dev.properties.thermostatOperatingState ~= nil and dev.properties.thermostatOperatingState == \"Idle\" then\n            self:debug(string.format(\"Skip '%s', because thermostatOperatingState is '%s'\", \n                                      dev.name, dev.properties.thermostatOperatingState))\n            goto continue\n        end\n\n        -- logic for Fibaro Heat Controler\n        if dev.properties.heatRequired ~= nil and dev.properties.heatRequired == false then\n            self:debug(string.format(\"Skip '%s', because heatRequired is '%s'\", \n                                      dev.name, dev.properties.heatRequired))\n            goto continue\n        end\n\n        -- skip if window is opened\n        if dev.properties.windowOpened ~= nil and dev.properties.windowOpened == true then\n            self:debug(string.format(\"Skip '%s', because windowOpened is '%s'\", \n                                      dev.name, dev.properties.windowOpened))\n            goto continue\n        end\n\n        if isWindowOpenedInDeviceRoom(dev.id, self.window_closed_delay) == true then\n            self:debug(string.format(\"Skip '%s', because window is opened.\", dev.name))\n            goto continue\n        end\n\n        ------------------------ End of edge condition checks ------------------------\n\n        local thermochildren = {}\n\n        -- get temp sensors for Virtual Devices\n        if dev.properties.linkedDeviceType == \"Thermostat\" and dev.properties.thermostatMode == \"Heat\" then\n            \n            local linked_devs = dev.properties.devices\n            \n\n            for i=1,#linked_devs do\n                local linked_dev, status = api.get(string.format(\"/devices/%s\", linked_devs[i]))\n                if linked_dev.type == \"com.fibaro.temperatureSensor\" then\n                    table.insert(thermochildren, linked_devs[i])\n                end\n            end\n\n        else\n            -- get temp sensors for real devices\n            thermochildren = fibaro.getDevicesID({type = \"com.fibaro.temperatureSensor\", \n                                                  enabled = true, \n                                                  parentId = dev.parentId})\n        end\n\n\n        local currentTemps = {}\n\n        for j=1,#thermochildren do \n            local currentTemp = hub.getValue(thermochildren[j], \"value\")\n            currentTemps[#currentTemps + 1 ] = currentTemp\n            local device_temp_increase = tonumber(dev.properties.heatingThermostatSetpoint) - tonumber(currentTemp)\n            \n            -- assign highest temp increase\n            if self.temperature_increase == nil then\n                self.temperature_increase = device_temp_increase\n                self.temperature_increase_deviceID = thermochildren[j]\n                self.temperature_increase_device_setpoint = dev.properties.heatingThermostatSetpoint\n            elseif device_temp_increase > self.temperature_increase then\n                self.temperature_increase = device_temp_increase\n                self.temperature_increase_device_setpoint = dev.properties.heatingThermostatSetpoint\n                self.temperature_increase_deviceID = thermochildren[j]\n                self.temperature_increase_device_name = hub.getValue(thermochildren[j], \"name\")\n            end\n        end\n        \n        filteredDevices[i].properties.currentTemperature = currentTemps\n\n        ::continue::\n    end    \n\n    self:debug(\"self.temperature_increase: \", self.temperature_increase)\nend"},{"name":"getDoorSensors","isMain":false,"isOpen":true,"content":"-- Function looks for door sensors in 'climate' category\n\nfunction getDoorSensorsInDeviceRoom(ID)\n    if ID == nil then\n        error(\"Argument 'ID' is missing.\")\n    end\n    local roomID = fibaro.getRoomID(ID)\n    doorSensors = fibaro.getDevicesID({roomID = roomID, enabled = true, type = \"com.fibaro.FGDW002\"})\n    -- filter by category: climate\n    local filtered_sensors = {}\n    for i=1,#doorSensors do\n        local data, status = api.get(\"/devices/\" .. doorSensors[i])\n        local categories = data.properties.categories\n        for j=1,#categories do\n            -- if door sensor is in cilmate category, then it affects heating\n            if categories[j] == \"climate\" then\n                table.insert(filtered_sensors, doorSensors[i])\n                break\n            end\n        end\n    end\n\n    return filtered_sensors\nend\n\nfunction isWindowOpenedInDeviceRoom(ID, window_opened_delay)\n    if ID == nil then\n        error(\"Argument 'ID' is missing.\")\n    end\n    if window_opened_delay == nil then\n        error(\"Argument 'window_opened_delay' is missing.\")\n    end\n    if isNumber(window_opened_delay) == false then\n        error(\"Argument 'window_opened_delay' must be a number.\")\n    end\n    \n     -- check all door sensors in device's room\n    local doorSensors = getDoorSensorsInDeviceRoom(ID)\n    local window = false\n    for i=1,#doorSensors do\n        if fibaro.getValue(doorSensors[i], \"value\") == true or \n           os.time() - fibaro.getValue(doorSensors[i], \"lastBreached\") <= window_opened_delay then\n            window = true\n            break -- if at least one window/door opened then stop iteration\n        \n        end\n    end\n    return window\nend\n"}]}